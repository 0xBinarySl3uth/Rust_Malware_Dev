// Importing windows crate, allows for WinAPI integration
use windows::Win32::System::Memory::{VirtualAlloc, VirtualFree, MEM_COMMIT, PAGE_READWRITE};

/*
Documentation:
    - https://doc.rust-lang.org/std/thread/index.html

 */

// Function waits 10 seconds before closing the program
fn wait() {
    // Integrate sleep function for the current thread (the thread that this program will be running on)
    std::thread::sleep(std::time::Duration::from_secs(10));
    println!(">> Sleeping Done!\n");
}

// Allocate memory for 30 integers (4 bytes)
// Function that returns the result value
fn run() -> windows_core::Result<()> {
    // Allocate memory for 30 integers (4 bytes)
    let size = std::mem::size_of::<i32>() * 30;
    // unsafe{}     -> Allows us
    let mem_ptr = unsafe {
        VirtualAlloc(
            None, // Passing None to represent null
            size as usize,
            MEM_COMMIT,
            PAGE_READWRITE,
        )
    };

    // Check if allocation succeeded
    let mem_ptr = if mem_ptr.is_null() {
        let last_error = windows::core::Error::from_win32();
        return Err(last_error);
    } else {
        mem_ptr
    };

    // Access the allocated memory
    let data: &mut [i32] = unsafe { std::slice::from_raw_parts_mut(mem_ptr as *mut i32, 100) };

    // Initialize the data
    for i in 0..100 {
        data[i] = i as i32;
    }

    // Print the allocated data
    println!("Memory Address: {:?}", mem_ptr);

    // Free the allocated memory
    let _result = unsafe { VirtualFree(mem_ptr, 0, windows::Win32::System::Memory::MEM_RELEASE) ?};
    Ok(()) // Return Ok(()) when freeing the memory is successful

}


fn main() {
    if let Err(err) = run() {
        eprintln!("Error: {:?}", err);
    }

    wait()
}